<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <!--<link rel="manifest" href="manifest.json" />-->
    <link href="https://fonts.cdnfonts.com/css/perfect-dos-vga-437" rel="stylesheet">
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <!-- needed for CodeMirror editor -->
    <link href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.62.0/codemirror.min.css" rel="stylesheet">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.62.0/theme/dracula.min.css" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.62.0/codemirror.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.62.0/mode/xml/xml.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.62.0/mode/javascript/javascript.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.62.0/mode/css/css.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.62.0/mode/htmlmixed/htmlmixed.min.js"></script>
    <style>
        textarea {
            font-size: large;
            font-family: 'Perfect DOS VGA 437', sans-serif;
            background-color: #B3C0B7;
        }
        button {
            font-family: 'Perfect DOS VGA 437', sans-serif;
        }
        body, html {
            margin: 0;
            height: 100%;
            font-size: large;
            font-family: 'Perfect DOS VGA 437', sans-serif;
            background: black;
            color: white;
        }
        .btn {
            width:50vw;
            text-align:center;
            height:2.5em;
            font-size:large
        }
        legend {
            text-align: left;
        }
    </style>
    <link rel="icon" href="data:,">
</head>
<body>
    <textarea id="prompt-input" style="width:99vw;height:4em;font-size:large" placeholder="Enter prompt or touch screen for voice prompt"></textarea>
    <div style="text-align:right">
        <input type="checkbox" id="code-cbx" style="width:2em;height:2em"><label for="code-cbx">Code</label>
        <input checked type="checkbox" id="enable-voice" style="width:2em;height:2em"><label for="enable-voice">Voice</label>
        <button id="submit-button" class="btn">Submit</button>
    </div>
    <fieldset>
        <legend>ChatGPT Response</legend>
        <div id="openai-output" spellcheck="false" style="white-space:pre-wrap; color: white"></div>
    </fieldset>
    <div id="save-div" style="display: none; text-align: right">
        <a id="gp-link" target="_blank" title="There is some delay before it's available-try passing random parameters" href="#"></a>
        <fieldset>
            <legend>Code Editor</legend>
            <div style="text-align:left" id="code-editor"></div>
            <button id="save-code" class="btn">Save</button>
        </fieldset>
        <fieldset>
            <legend>Output Web Application</legend>
            <div id="code-output"></div>
        </fieldset>
    </div>
    <script>
        const body = document.body;
        const $ = id => document.getElementById(id);
        const cancelSpeaking = () => { let wasSpeaking = speechSynthesis.speaking; timer.disableSpeaking(); stopStreaming = true; speechSynthesis.cancel(); return wasSpeaking; }
        body.addEventListener('beforeunload', () => this.cancelSpeaking());
        let enableVoice = $('enable-voice'), codeCbx = $('code-cbx'), submitBtn = $('submit-button'), promptInput = $('prompt-input'), openaiOutput = $('openai-output'),
            codeOutput = $('code-output'), saveCode = $('save-code'), saveDiv = $('save-div'), gpLink = $('gp-link'), stopStreaming = false, history = [], sentences = [], sIndex = 0;
        promptInput.focus(); enableVoice.disabled = false;
        enableVoice.addEventListener('change', e => localStorage.setItem('ENABLE_VOICE', e.target.checked));
        enableVoice.checked = (localStorage.getItem('ENABLE_VOICE') ?? "true") === "true";

        submitBtn.addEventListener('click', async () => {
            codeOutput.textContent = ''; gpLink.textContent = '';
            const words = promptInput.value.split(' ');
            if (words.length < 3) body.style.background = words.join(''); //easter egg for my son
            cancelSpeaking();
            let token = localStorage.getItem('OPENAI_API_KEY') || prompt("Please input OpenAI API key (stored in browser cache)", "")?.trim();
            if (token && token.length >= 10) localStorage.setItem('OPENAI_API_KEY', token);
            await openAiSend(promptInput, openaiOutput, token);
            history.push({ role: 'user', content: promptInput.value }, { role: 'assistant', content: openaiOutput.textContent });
            if (history.length > 4) { history.shift(); history.shift(); }
            outputHtml(codeOutput);
        });
        saveCode.addEventListener('click', () => outputHtml(codeOutput, true));
        var editor = null;
        const outputHtml = (div, fromSave = false) => {
            if (!codeCbx.checked) return saveDiv.style.display = 'none'
            saveDiv.style.display = 'block', div.style.background = 'white', div.style.color = 'black', div.innerHTML = '';
            const r = editor && fromSave ? editor.getValue() : openaiOutput.textContent.match(/```(?:html)?([\s\S]*?)```/i)?.[1] || openaiOutput.textContent;
            editor?.getWrapperElement()?.remove();
            editor = CodeMirror($('code-editor'), {
                lineNumbers: true,
                mode: "htmlmixed",
                theme: "dracula",
                htmlMode: true,
                matchTags: { bothTags: true },
                autoCloseTags: true,
                autoCloseBrackets: true
            });
            editor.setValue(r);
            let iframe = document.createElement('iframe');
            iframe.width = '99%', iframe.height = `${innerHeight >> 1}`, iframe.srcdoc = r;
            div.appendChild(iframe);
            if (!fromSave || !confirm("Press OK to also push to GitHub")) return;
            let token2 = localStorage.getItem('GITHUB_API_KEY') || prompt("Please input GitHub API key (requires repo permissions)", "")?.trim();
            if (token2 && token2.length >= 10) localStorage.setItem('GITHUB_API_KEY', token2);
            let path = prompt("Provide a path (uses gh-pages branch)", localStorage.getItem('GITHUB_PATH')?.replace('null', '') || "jay23606/chat-gpt-voice/contents/html/test.html");
            localStorage.setItem('GITHUB_PATH', path);
            let p = path.replace('contents/', '').split('/');
            let gp = `https://${p[0]}.github.io/${p[1]}/${p.slice(2).join('/')}`
            let data = btoa(`<!-- ${gp} -->\n${r}`), branch = 'gh-pages';
            let init = {
                method: 'PUT', headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${token2}` },
                body: { message: "gpt-voice commit", committer: { name: "gpt-voice", email: "gpt-voice@mail.com" }, content: data, branch: branch }
            };
            fetch(`https://api.github.com/repos/${path}?ref=${branch}`, { method: 'HEAD' })
                .then(response => response.status === 404 ? Promise.resolve() : response.headers.get('ETag'))
                .then(etag => {
                    if (etag) init.body.sha = etag.substring(3, etag.length - 1);
                    init.body = JSON.stringify(init.body);
                    fetch(`https://api.github.com/repos/${path}`, init).then(() => { gpLink.href = gp; gpLink.textContent = "Open in GitHub Pages"; });
                });
        }

        const recognition = (input, btn, lang = 'en-US') => {
            var SpeechRecognition = SpeechRecognition || webkitSpeechRecognition;
            let recognition = new SpeechRecognition();
            recognition.lang = lang;
            body.onclick = e => ((e.target === body || e.target.id === 'openai-output') && enableVoice.checked) ? ((cancelSpeaking()) ? '' : recognition.start()) : '';
            recognition.onresult = e => { input.value = e.results[0][0].transcript; if (btn) btn.click() }
            recognition.onspeechend = () => recognition.stop();
        }
        recognition(promptInput, submitBtn);

        const timer = {
            iid: 0, disableSpeaking: function () { if (this.iid) clearInterval(this.iid) },
            enableSpeaking: function () {
                this.disableSpeaking();
                this.iid = setInterval(() => {
                    if (!enableVoice.checked) return;
                    if (!speechSynthesis.speaking && sentences.length > 0 && sentences.length > sIndex) {
                        var utter = new SpeechSynthesisUtterance();
                        utter.text = sentences[sIndex].join(''), utter.lang = 'en-AU', utter.rate = 1.4;
                        speechSynthesis.speak(utter);
                        sIndex++;
                    }
                }, 500);
            }
        };

        const openAiSend = async (input, output, token) => {
            let system = [];
            if (codeCbx.checked) system.push({ "role": "system", "content": "Write html only,no explanation.Put script tag in body.Use lamdas to save space" });
            const response = await fetch('https://api.openai.com/v1/chat/completions', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${token}` },
                body: JSON.stringify({ model: "gpt-3.5-turbo", temperature: 0.8, stream: true, messages: [...system, ...history, { role: "user", content: input.value }] })
            });
            sentences = [], sIndex = 0, stopStreaming = false;
            let arr = [], arr2 = [], reader = response.body.getReader();
            reader.onerror = err => cancelSpeaking();
            timer.enableSpeaking();
            for (; ;) {
                const { done, value } = await reader.read();
                if (done) return;
                const decoder = new TextDecoder(), chunk = decoder.decode(value, { stream: true }), lines = chunk.split('\n');
                for (const line of lines) {
                    if (stopStreaming) return;
                    if (line.length === 0 || line.startsWith(':')) continue;
                    if (line === 'data: [DONE]') {
                        if (!enableVoice.checked) return;
                        if (arr.length) sentences.push(arr);
                        return;
                    }
                    const { choices } = JSON.parse(line.substring(6));
                    if (!choices) continue;
                    const word = choices[0].delta.content || '';
                    arr.push(word); arr2.push(word);
                    if (/[.;!?]$/.test(word.trimEnd())) { sentences.push(arr); arr = []; }
                    output.textContent = arr2.join('');
                }
            }
        } //Add accordian-like thingy with the fieldset (patent pending)
        document.querySelectorAll('legend').forEach((legend) => legend.addEventListener('click', () => {
            const c = legend.parentNode.children;
            for (let i = 1; i < c.length; i++)  c[i].style.display = (c[i].style.display === 'none') ? 'block' : 'none';
        }));
    </script>
</body>
</html>
